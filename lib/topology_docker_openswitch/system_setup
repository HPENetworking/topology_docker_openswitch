#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2015-2016 Hewlett Packard Enterprise Development LP
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

"""
OpenSwitch - Topology Docker OpenSwitch support node system setup script.

PLEASE NOTE:

    This file is a script that is copied as-is to the container.
    Once inside the container, it is executed with the purpose of configuring
    the container and assert that is it ready for testing.
"""

from __future__ import unicode_literals, absolute_import
from __future__ import print_function, division

from re import search
from time import sleep
from os.path import exists
from json import loads, dumps
from logging import getLogger
from collections import OrderedDict
from socket import gethostname, socket, AF_UNIX, SOCK_STREAM
from subprocess import check_call, check_output, CalledProcessError  # noqa


__version__ = '1.0.0'

ALL_CHECKS = OrderedDict((
    ('SWNS_NETNS_CREATED', 100),
    ('HWDESC_SYMLINK_CREATED', 110),
    ('OVSDB_SOCKET_CREATED', 200),
    ('SWITCHD_PID_FILE_CREATED', 210),
    ('SWITCH_HOSTNAME_SET', 220),
    ('CUR_CFG_SET', 230),
    ('SWITCHD_STATUS_ACTIVE', 240),
))  # This is MUST be the same as OpenSwitchNode.ALL_CHECKS

log = getLogger(__name__)


class Ovsdb(object):

    OVSDB_SOCK = '/var/run/openvswitch/db.sock'

    def __init__(self):
        """
        Ovsdb helper class to perform transactions.
        """

        self.query = {
            'method': 'transact',
            'params': [
                'OpenSwitch',
                {
                    'op': 'select',
                    'table': 'System',
                    'where': [],
                    'columns': ['cur_hw']
                }
            ],
            'id': id(self)
        }
        self._sock = socket(AF_UNIX, SOCK_STREAM)
        self._sock.connect(Ovsdb.OVSDB_SOCK)

    def cur_cfg_is_set(self):
        """
        Check that the query for the cur_hw succeed.
        """

        self._sock.send(dumps(self.query))
        response = loads(self._sock.recv(4096))
        try:
            return response['result'][0]['rows'][0]['cur_hw'] == 1
        except IndexError:
            return False


def check_until_timeout(check, check_name, exit_code, timeout):
    """
    Execute a check until timeout or until the check returns positive.

    :param function check: Check function to call repeatedly.
    :param str check_name: Human readable name of the check.
    :param int exit_code: If the check doesn't succeed, the program will quit
     with this exit code.
    :param int timeout: Time (in seconds) that the function will ask for the
     check to pass.
    """
    log.info('Starting check: {}'.format(check_name))

    for i in range(0, timeout * 10):
        if check():
            log.info('Check {} passed. Continue.'.format(check_name))
            return True
        sleep(0.1)

    log.fatal('Timeout in check: {}'.format(check_name))
    exit(exit_code)


def create_interfaces(available):
    """
    Create OpenSwitch container interfaces.

    This method parses the ``ports.yaml`` file, renames and moves to the swns
    network namespace the interfaces created by the Topology Modular framework
    and creates the remaining using tuntap interfaces.

    :param list available: List of available interfaces names.
    :rtype: OrderedDict
    :return: A ordered dictionary that maps the original name of the interface
     with the new name.
    """
    # FIXME: IMPLEMENT!!!
    """
    import yaml

    # Read ports from hardware description
    with open('{}/ports.yaml'.format(hwdesc_dir), 'r') as fd:
        ports_hwdesc = yaml.load(fd)
    hwports = [str(p['name']) for p in ports_hwdesc['ports']]

    # Get list of already created ports
    not_in_swns = check_output(shsplit(
        'ls /sys/class/net/'
    )).split()
    in_swns = check_output(shsplit(
        'ip netns exec swns ls /sys/class/net/'
    )).split()

    create_cmd_tpl = 'ip tuntap add dev {hwport} mode tap'
    netns_cmd_tpl = 'ip link set {hwport} netns swns'
    rename_int = 'ip link set {portlbl} name {hwport}'

    # Save port mapping information
    mapping_ports = {}

    # Map the port with the labels
    for portlbl in not_in_swns:
        if portlbl in ['lo', 'oobm', 'bonding_masters']:
            continue
        hwport = hwports.pop(0)
        mapping_ports[portlbl] = hwport
        logging.info(
            '  - Port {portlbl} moved to swns netns as {hwport}.'.format(
                **locals()
            )
        )
        check_call(shsplit(rename_int.format(**locals())))
        check_call(shsplit(netns_cmd_tpl.format(hwport=hwport)))

    # Writting mapping to file
    with open('/tmp/ports_mapping.json', 'w') as json_file:
        json_file.write(dumps(mapping_ports))

    for hwport in hwports:
        if hwport in in_swns:
            logging.info('  - Port {} already present.'.format(hwport))
            continue

        logging.info('  - Port {} created.'.format(hwport))
        check_call(shsplit(create_cmd_tpl.format(hwport=hwport)))
        check_call(shsplit(netns_cmd_tpl.format(hwport=hwport)))
    check_call(shsplit('touch /tmp/ops-virt-ports-ready'))
    logging.info('  - Ports readiness notified to the image')
    """


def pre_checks(timeout):
    """
    Checks that needs to be executed BEFORE the creation of the interfaces.

    :param int timeout: Timeout in seconds for checks to pass.
    """
    checks_list = OrderedDict((
        (
            'SWNS_NETNS_CREATED',
            lambda: exists('/var/run/netns/swns'),
        ),
        (
            'HWDESC_SYMLINK_CREATED',
            lambda: exists('/etc/openswitch/hwdesc'),
        )
    ))

    for check_name, check in checks_list.items():
        exit_code = ALL_CHECKS[check_name]
        check_until_timeout(check, check_name, exit_code, timeout)


def post_checks(timeout):
    """
    Checks that needs to be executed AFTER the creation of the interfaces.

    :param int timeout: Timeout in seconds for checks to pass.
    """

    def switchd_status_is_active():
        """
        Custom check to verify that switchd is active.
        """
        try:
            output = check_output(['systemctl', 'status', 'switchd'])
        except CalledProcessError as error:
            output = error.output
        return search(r'Active: active \(running\)', output)

    ovsdb = Ovsdb()

    checks_list = OrderedDict((
        (
            'OVSDB_SOCKET_CREATED',
            lambda: exists(Ovsdb.OVSDB_SOCK),
        ),
        (
            'SWITCHD_PID_FILE_CREATED',
            lambda: exists('/var/run/openvswitch/ops-switchd.pid'),
        ),
        (
            'SWITCH_HOSTNAME_SET',
            lambda: gethostname() != 'switch',
        ),
        (
            'CUR_CFG_SET',
            lambda: ovsdb.cur_cfg_is_set,
        ),
        (
            'SWITCHD_STATUS_ACTIVE',
            lambda: switchd_status_is_active,
        )
    ))

    for check_name, check in checks_list.items():
        exit_code = ALL_CHECKS[check_name]
        check_until_timeout(check, check_name, exit_code, timeout)


def parse_args(argv=None):
    """
    Argument parsing routine.

    :param argv: A list of argument strings.
    :rtype argv: list
    :return: A parsed and verified arguments namespace.
    :rtype: :py:class:`argparse.Namespace`
    """
    from argparse import ArgumentParser

    parser = ArgumentParser(
        description=(
            'Topology Modular - OpenSwitch Support Node Setup Script'
        )
    )

    parser.add_argument(
        '-v', '--verbose',
        help='Increase verbosity level',
        default=0,
        action='count'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=(__version__)
    )

    parser.add_argument(
        '--checks-timeout',
        help='Timeout for a check to be ready in seconds',
        default=30,
        type=int
    )
    parser.add_argument(
        '--skip-boot-checks',
        default=None,
        help=(
            'Coma-separated list of checks to skip. '
            'Use ALL to disable all checks'
        )
    )
    parser.add_argument(
        '--available',
        help='JSON file with available interfaces provided by the framework'
    )

    args = parser.parse_args(argv)
    args = validate_args(args)
    return args


def validate_args(args):
    """
    Validate that arguments are valid.

    :param args: An arguments namespace.
    :type args: :py:class:`argparse.Namespace`
    :return: The validated namespace.
    :rtype: :py:class:`argparse.Namespace`
    """

    # Configure logging
    import logging

    format = '%(asctime)s:::%(levelname)s:::%(message)s'
    levels = {
        0: logging.ERROR,
        1: logging.WARNING,
        2: logging.INFO,
        3: logging.DEBUG,
    }

    level = levels.get(args.verbose, logging.DEBUG)
    logging.basicConfig(format=format, level=level)

    # Log starting and debug arguments
    log.info(
        'Topology Modular - OpenSwitch Support Node '
        'Setup Script is starting... '
    )
    log.debug('Raw arguments:\n{}'.format(args))

    # Interpret and validate boot checks deactivations
    if args.skip_boot_checks is not None:

        skipped = args.skip_boot_checks.split(',')
        if 'ALL' in skipped:
            skipped = list(ALL_CHECKS.keys())
        else:
            for check in skipped:
                if check not in ALL_CHECKS:
                    raise Exception(
                        'Unknown boot check "{}"'.format(check)
                    )

        args.skip_boot_checks = sorted(skipped)

        log.warning(
            'Skipping boot checks:\n{}'.format(','.join(args.skip_boot_checks))
        )

    return args


def main():
    args = parse_args()

    # Create pre-interfaces boot checks
    if not args.skip_boot_checks:
        log.info('Executing pre-interfaces checks...')
        pre_checks(args.checks_timeout)

    # Create interfaces
    log.info('Creating interfaces... Please wait...')

    with open(args.available, 'r') as fd:
        available = loads(fd.read(), object_pairs_hook=OrderedDict)

    ports_mapping = create_interfaces(available)

    # Write new ports mapping
    with open(args.available, 'w') as fd:
        fd.write(dumps(ports_mapping, indent=4))

    # Create post-interfaces boot checks
    if not args.skip_boot_checks:
        log.info('Executing post-interfaces checks...')
        post_checks(args.checks_timeout)


if __name__ == '__main__':
    main()
